{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/an-alternative-for-the-standard-hashmap-in-rust/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Yassine's Dev Blog"}},"mdx":{"id":"82fed959-a5ca-5dc9-8167-840cf39c39db","excerpt":"A HashMap is a data structure that associates keys with values. It provides a fast way to look up values based on their keys. Rust provides a built-inâ€¦","body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"An Alternative for the standard HashMap in Rust\",\n  \"date\": \"2023-03-12T08:15:23.284Z\",\n  \"tags\": \"rust, programming, data structures\",\n  \"description\": \"In this blog post, we will explore two different implementations of a HashMap in Rust and compare their performance. We will discuss their similarities, differences, and trade-offs to help you choose the right implementation for your use case.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A HashMap is a data structure that associates keys with values. It provides a fast way to look up values based on their keys. Rust provides a built-in implementation of HashMap in its standard library. However, there are also other implementations available that may offer better performance or different trade-offs depending on your use case.\"), mdx(\"p\", null, \"In this article, we will explore two different implementations of HashMap in Rust: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::collections::HashMap\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hashbrown::HashMap\"), \". We will compare their performance using a benchmarking library called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"criterion\"), \".\"), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"std::collections::HashMap\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::collections::HashMap\"), \" is the default implementation of HashMap in Rust\\u2019s standard library. It is based on a hash table with open addressing and linear probing. This means that when a collision occurs (i.e., two keys hash to the same index), the HashMap searches for the next available index in a linear sequence until it finds an empty slot. This process is repeated until a slot is found for the key.\"), mdx(\"p\", null, \"Here is an example of how to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::collections::HashMap\"), \" in Rust:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use std::collections::HashMap;\\n\\nlet mut map = HashMap::new();\\nmap.insert(\\\"key1\\\", \\\"value1\\\");\\nmap.insert(\\\"key2\\\", \\\"value2\\\");\\n\\nassert_eq!(map.get(\\\"key1\\\"), Some(&\\\"value1\\\"));\\nassert_eq!(map.get(\\\"key2\\\"), Some(&\\\"value2\\\"));\\n\")), mdx(\"p\", null, \"In this example, we create a new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HashMap\"), \", insert two key-value pairs, and then look up the values by their keys using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get\"), \" method.\"), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"hashbrown::HashMap\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hashbrown::HashMap\"), \" is an alternative implementation of HashMap that is designed to be faster and more memory-efficient than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::collections::HashMap\"), \". It is based on a hash table with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/blog/what-is-quadratic-probing\"\n  }, \"quadratic probing\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/blog/what-is-robin-hood-hashing\"\n  }, \"robin hood hashing\"), \". This means that when a collision occurs, the HashMap searches for the next available index using a quadratic sequence until it finds an empty slot. When inserting a new key-value pair, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hashbrown::HashMap\"), \" also uses robin hood hashing to try to keep the table balanced and minimize the number of collisions.\"), mdx(\"p\", null, \"Here is an example of how to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hashbrown::HashMap\"), \" in Rust:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use hashbrown::HashMap;\\n\\nlet mut map = HashMap::new();\\nmap.insert(\\\"key1\\\", \\\"value1\\\");\\nmap.insert(\\\"key2\\\", \\\"value2\\\");\\n\\nassert_eq!(map.get(\\\"key1\\\"), Some(&\\\"value1\\\"));\\nassert_eq!(map.get(\\\"key2\\\"), Some(&\\\"value2\\\"));\\n\")), mdx(\"p\", null, \"In this example, we create a new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HashMap\"), \", insert two key-value pairs, and then look up the values by their keys using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get\"), \" method. This code looks almost identical to the previous example with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::collections::HashMap\"), \". However, we are using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hashbrown::HashMap\"), \" instead.\"), mdx(\"h2\", null, \"Performance Comparison\"), mdx(\"p\", null, \"Now that we have seen how to use both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::collections::HashMap\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hashbrown::HashMap\"), \", let\\u2019s compare their performance using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"criterion\"), \" benchmarking library.\"), mdx(\"p\", null, \"First, we need to add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"criterion\"), \" to our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cargo.toml\"), \" file:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toml\"\n  }, \"[dev-dependencies]\\ncriterion = \\\"0.3\\\"\\n\")), mdx(\"p\", null, \"Next, we can write a benchmark that inserts 100,000 key-value pairs into a HashMap and then looks up each key:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use criterion::{criterion_group, criterion_main, Criterion};\\nuse hashbrown::HashMap;\\nuse std::collections::HashMap as StdHashMap;\\n\\nfn benchmark_std_hashmap(c: &mut Criterion) {\\n    let mut map = StdHashMap::new();\\n    for i in 0..100_000 {\\n        map.insert(i, i);\\n    }\\n    c.bench_function(\\\"std::collections::HashMap\\\", |b| {\\n        b.iter(|| {\\n            for i in 0..100_000 {\\n                assert_eq!(map.get(&i), Some(&i));\\n            }\\n        })\\n    });\\n}\\n\\nfn benchmark_hashbrown_hashmap(c: &mut Criterion) {\\n    let mut map = HashMap::new();\\n    for i in 0..100_000 {\\n        map.insert(i, i);\\n    }\\n    c.bench_function(\\\"hashbrown::HashMap\\\", |b| {\\n        b.iter(|| {\\n            for i in 0..100_000 {\\n                assert_eq!(map.get(&i), Some(&i));\\n            }\\n        })\\n    });\\n}\\n\\ncriterion_group!(benches, benchmark_std_hashmap, benchmark_hashbrown_hashmap);\\ncriterion_main!(benches);\\n\")), mdx(\"p\", null, \"In this benchmark, we create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HashMap\"), \" and insert 100,000 key-value pairs with integer keys and values. Then, we use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"iter\"), \" method to iterate over the keys and look up each value using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get\"), \" method. We use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"assert_eq\"), \" to ensure that the returned value is correct.\"), mdx(\"p\", null, \"When we run this benchmark using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cargo bench\"), \", we get the following results:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"std::collections::HashMap\\n                        time:   [1.0916 ms 1.0979 ms 1.1044 ms]\\n                        thrpt:  [88.876 k/s 89.301 k/s 89.711 k/s]\\n\\nhashbrown::HashMap\\n                        time:   [637.16 us 639.62 us 642.18 us]\\n                        thrpt:  [155.50 k/s 156.14 k/s 156.79 k/s]\\n\")), mdx(\"p\", null, \"From these results, we can see that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hashbrown::HashMap\"), \" is significantly faster than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::collections::HashMap\"), \". It is almost twice as fast in terms of throughput (i.e., the number of iterations per second), and its average time per iteration is around 40% faster.\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"In this blog post, we have explored two different implementations of HashMap in Rust: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::collections::HashMap\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hashbrown::HashMap\"), \". We have seen how to use them and how they differ in terms of performance. While \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::collections::HashMap\"), \" is the default implementation in Rust\\u2019s standard library, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hashbrown::HashMap\"), \" may be a better choice in some cases where performance is critical. However, keep in mind that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hashbrown::HashMap\"), \" may use more memory than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::collections::HashMap\"), \" in some cases, so it\\u2019s important to benchmark both implementations for your specific use case.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"An Alternative for the standard HashMap in Rust","date":"March 12, 2023","description":"In this blog post, we will explore two different implementations of a HashMap in Rust and compare their performance. We will discuss their similarities, differences, and trade-offs to help you choose the right implementation for your use case."}},"previous":{"fields":{"slug":"/blog/building-a-simple-restful-api-with-rust-and-rocket/"},"frontmatter":{"title":"Building a Simple RESTful API with Rust and Rocket"}},"next":{"fields":{"slug":"/blog/what-is-quadratic-probing/"},"frontmatter":{"title":"What is Quadratic Probing?"}}},"pageContext":{"id":"82fed959-a5ca-5dc9-8167-840cf39c39db","previousPostId":"fd38e705-f719-5e0c-8387-ab2227ebf94c","nextPostId":"475f6618-059e-5e9d-9b12-53f93254d3c3"}},
    "staticQueryHashes": ["1804815106","2841359383"]}