{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/building-a-simple-restful-api-with-rust-and-rocket/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Yassine's Dev Blog"}},"mdx":{"id":"fd38e705-f719-5e0c-8387-ab2227ebf94c","excerpt":"Rust is a modern and highly performant programming language that has seen rapid adoption for building complex systems, including web applications. When pairedâ€¦","body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Building a Simple RESTful API with Rust and Rocket\",\n  \"slug\": \"building-a-simple-restful-api-with-rust-and-rocket\",\n  \"date\": \"2023-03-11T11:12:03.284Z\",\n  \"tags\": \"rust, rocket, api, restful, web development\",\n  \"description\": \"In this blog post, we will walk through the process of building a simple RESTful API with Rust and the Rocket web framework. We'll cover topics such as request handling, routing, database integration, and error handling, providing a solid foundation for creating a scalable and reliable API. By the end of this post, you'll have a clear understanding of how to leverage Rust and Rocket to build powerful web applications.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Rust is a modern and highly performant programming language that has seen rapid adoption for building complex systems, including web applications. When paired with the Rocket web framework, Rust can be used to build powerful and scalable APIs quickly.\"), mdx(\"p\", null, \"In this tutorial, we will walk through building a simple RESTful API with Rust and Rocket. We\\u2019ll start by setting up a new Rocket project, defining routes to handle requests, integrating with a database, and handling errors. \"), mdx(\"h3\", null, \"Setting Up the Project\"), mdx(\"p\", null, \"Before we dive into defining our routes, we need to set up a new Rocket project. We\\u2019ll start by installing Rust on our machine and creating a new Rust project using Cargo, Rust\\u2019s package manager.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"$ cargo new rest-api\\n\")), mdx(\"p\", null, \"Next, we\\u2019ll add the Rocket dependency to our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cargo.toml\"), \" file.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toml\"\n  }, \"[dependencies]\\nrocket = \\\"0.5.0-rc.1\\\"\\n\")), mdx(\"p\", null, \"We\\u2019re now ready to start building our API with Rocket.\"), mdx(\"h3\", null, \"Defining Routes\"), mdx(\"p\", null, \"Routes are the entry points for our RESTful API, and in Rocket, defining routes is straightforward. We\\u2019ll define a simple route that returns a static message when a GET request is made to the root of our API.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[get(\\\"/\\\")]\\nfn index() -> &'static str {\\n    \\\"Welcome to our API!\\\"\\n}\\n\\n#[launch]\\nfn rocket() -> _ {\\n    rocket::build().mount(\\\"/\\\", routes![index])\\n}\\n\")), mdx(\"p\", null, \"In the above code snippet, we define an index function that returns a static message. We also define the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rocket\"), \" function, which is where we create an instance of our Rocket web application and mount our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index\"), \" route to the root of our API.\"), mdx(\"h3\", null, \"Request Handling\"), mdx(\"p\", null, \"Next, let\\u2019s look at how we can handle requests with Rocket. We\\u2019ll define a route that takes a query parameter, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \", and returns a personalized message.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[get(\\\"/hello/<name>\\\")]\\nfn hello(name: String) -> String {\\n    format!(\\\"Hello, {}!\\\", name)\\n}\\n\\n#[launch]\\nfn rocket() -> _ {\\n    rocket::build().mount(\\\"/\\\", routes![index, hello])\\n}\\n\")), mdx(\"p\", null, \"In the above code, we define a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hello\"), \" route that takes in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" parameter and returns a personalized message. We use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \" type to define the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" parameter and format a message that includes the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" parameter. We then mount our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hello\"), \" route to our Rocket instance.\"), mdx(\"h3\", null, \"Database Integration\"), mdx(\"p\", null, \"Our API is now responding to requests, but we haven\\u2019t yet integrated with a database. Rocket makes it easy to integrate with databases using its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rocket_contrib\"), \" library.\"), mdx(\"p\", null, \"We\\u2019ll use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"diesel\"), \" crate, an ORM for Rust, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rocket_sync_db_pools\"), \" crate, a synchronous database pooling executor for Rocket and Rust.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-toml\"\n  }, \"[dependencies]\\nrocket_sync_db_pools = \\\"0.4.4\\\"\\nserde = \\\"1.0\\\"\\nserde_derive = \\\"1.0\\\"\\ndiesel = { version = \\\"1.4.7\\\", features = [\\\"sqlite\\\"] }\\n\")), mdx(\"p\", null, \"Then, let\\u2019s create a new file \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"db.rs\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"use dotenv::dotenv;\\nuse std::env;\\nuse diesel::prelude::*;\\nuse diesel::r2d2::{self, ConnectionManager};\\nuse rocket::State;\\nuse rocket_sync_db_pools::{database, diesel::MysqlConnection, r2d2::ConnectionPool};\\n\\ndatabase(\\\"mysql_db\\\")\\npub struct DbConn(pub ConnectionPool<MysqlConnection>);\\n\\npub fn init_pool() -> DbConn {\\n    dotenv().ok();\\n    let database_url = env::var(\\\"DATABASE_URL\\\").expect(\\\"set DATABASE_URL\\\");\\n    let manager = ConnectionManager::<MysqlConnection>::new(database_url);\\n    let pool = r2d2::Pool::builder()\\n        .build(manager)\\n        .expect(\\\"Failed to create pool.\\\");\\n    DbConn(pool)\\n}\\n\")), mdx(\"p\", null, \"In the code block above, we use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"diesel\"), \" crate to define our connection to the database. We also use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rocket_sync_db_pools\"), \" crate and its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"database\"), \" macro to define a database connection pool.\"), mdx(\"h3\", null, \"Error Handling\"), mdx(\"p\", null, \"Finally, let\\u2019s look at how we can handle errors in our API. Rocket provides a built-in error handling system that allows us to define custom error types and easily return them to clients.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[catch(404)]\\nfn not_found(req: &Request) -> Json<Value> {\\n    Json(json!({\\n        \\\"status\\\": 404,\\n        \\\"reason\\\": \\\"Resource Not Found\\\",\\n        \\\"requested_path\\\": req.uri().to_string()\\n    }))\\n}\\n\\n#[catch(500)]\\nfn internal_error() -> Json<Value> {\\n    Json(json!({\\n        \\\"status\\\": 500,\\n        \\\"reason\\\": \\\"Internal Server Error\\\",\\n    }))\\n}\\n\\n#[launch]\\nfn rocket() -> _ {\\n    rocket::build()\\n        .attach(DbConn::fairing())\\n        .mount(\\\"/\\\", routes![index, hello])\\n        .register(\\\"/\\\", catchers![not_found, internal_error])\\n}\\n\")), mdx(\"p\", null, \"In the code snippet above, we define two error handler functions, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"not_found\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"internal_error\"), \", to handle 404 and 500 errors respectively. We then register these handlers with the API using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"register\"), \" method.\"), mdx(\"h3\", null, \"Conclusion\"), mdx(\"p\", null, \"We\\u2019ve covered a lot of ground in this tutorial! By leveraging Rust and Rocket, we were able to build a simple RESTful API that can handle requests, integrate with a database, and handle errors. \"), mdx(\"p\", null, \"While this tutorial only scratches the surface of what\\u2019s possible with Rust and Rocket, it should give you a solid foundation for building more complex APIs in the future. With its performance, safety, and ease-of-use, Rust is an excellent choice for web development, and Rocket makes it easy to build powerful web applications quickly.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Building a Simple RESTful API with Rust and Rocket","date":"March 11, 2023","description":"In this blog post, we will walk through the process of building a simple RESTful API with Rust and the Rocket web framework. We'll cover topics such as request handling, routing, database integration, and error handling, providing a solid foundation for creating a scalable and reliable API. By the end of this post, you'll have a clear understanding of how to leverage Rust and Rocket to build powerful web applications."}},"previous":{"fields":{"slug":"/blog/introduction/"},"frontmatter":{"title":"Introducing myself and my new dev blog"}},"next":{"fields":{"slug":"/blog/an-alternative-for-the-standard-hashmap-in-rust/"},"frontmatter":{"title":"An Alternative for the standard HashMap in Rust"}}},"pageContext":{"id":"fd38e705-f719-5e0c-8387-ab2227ebf94c","previousPostId":"c7138b45-e633-5280-b863-97b39b875046","nextPostId":"82fed959-a5ca-5dc9-8167-840cf39c39db"}},
    "staticQueryHashes": ["1804815106","2841359383"]}