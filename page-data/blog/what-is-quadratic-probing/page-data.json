{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/what-is-quadratic-probing/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Yassine's Dev Blog"}},"mdx":{"id":"475f6618-059e-5e9d-9b12-53f93254d3c3","excerpt":"Hash tables are one of the most commonly used data structures in computer science. They allow us to store and retrieve data quickly, making them ideal for tasksâ€¦","body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"What is Quadratic Probing?\",\n  \"slug\": \"what-is-quadratic-probing\",\n  \"date\": \"2023-03-12T10:23:57.284Z\",\n  \"tags\": \"algorithms, data structures, hash tables\",\n  \"description\": \"In this blog post, we dive into the world of hash table probing and explore quadratic probing in detail. We compare it with other types of probing and discuss its strengths and weaknesses. By the end of this post, readers will have a better understanding of quadratic probing and when to use it in their code.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Hash tables are one of the most commonly used data structures in computer science. They allow us to store and retrieve data quickly, making them ideal for tasks such as caching, indexing, and searching. However, hash tables are not perfect, and sometimes collisions can occur when two or more keys map to the same index. This is where probing comes in.\"), mdx(\"p\", null, \"Probing is the process of finding an empty slot in a hash table when a collision occurs. There are several types of probing techniques, including linear probing, quadratic probing, and double hashing. In this post, we will focus on quadratic probing.\"), mdx(\"h2\", null, \"What is Quadratic Probing?\"), mdx(\"p\", null, \"Quadratic probing is a probing technique that uses a quadratic function to search for an empty slot in a hash table. When a collision occurs, quadratic probing looks for the next empty slot by using the formula:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"hash(key, i) = (hash(key) + i^2) % table_size\\n\")), mdx(\"p\", null, \"where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hash(key)\"), \" is the hash value of the key, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" is the number of collisions that have occurred, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"table_size\"), \" is the size of the hash table. Quadratic probing tries to find an empty slot by checking indices that are farther away from the original hash index, which reduces the likelihood of clustering.\"), mdx(\"p\", null, \"Let\\u2019s take a look at an example. Suppose we have a hash table of size 7 and the following keys:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"[43, 23, 37, 19, 36, 28]\\n\")), mdx(\"p\", null, \"We will use the following hash function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"hash(key) = key % 7\\n\")), mdx(\"p\", null, \"The initial hash indices for each key are:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"[1, 2, 2, 5, 1, 0]\\n\")), mdx(\"p\", null, \"As you can see, keys 37 and 36 both map to index 2, causing a collision. With quadratic probing, we can search for the next empty slot by using the formula:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"hash(37, 1) = (hash(37) + 1^2) % 7 = (2 + 1) % 7 = 3\\nhash(36, 1) = (hash(36) + 1^2) % 7 = (1 + 1) % 7 = 2\\nhash(37, 2) = (hash(37) + 2^2) % 7 = (2 + 4) % 7 = 6\\nhash(36, 2) = (hash(36) + 2^2) % 7 = (1 + 4) % 7 = 5\\n\")), mdx(\"p\", null, \"The new hash indices for keys 37 and 36 are:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"[1, 2, 3, 5, 6, 0]\\n\")), mdx(\"p\", null, \"As you can see, quadratic probing has successfully found empty slots for both keys.\"), mdx(\"h2\", null, \"Quadratic Probing vs Linear Probing\"), mdx(\"p\", null, \"Quadratic probing is often compared to linear probing, another popular probing technique. With linear probing, we search for the next empty slot by using the formula:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"hash(key, i) = (hash(key) + i) % table_size\\n\")), mdx(\"p\", null, \"where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" is the number of collisions that have occurred. Linear probing checks indices that are adjacent to the original hash index, which can lead to clustering.\"), mdx(\"p\", null, \"In general, quadratic probing tends to have better performance than linear probing when the load factor (the ratio of filled slots to total slots) is low. However, as the load factor increases, quadratic probing can become less efficient than linear probing.\"), mdx(\"h2\", null, \"When to Use Quadratic Probing\"), mdx(\"p\", null, \"Quadratic probing is a good choice for hash tables when the load factor is low to medium and the hash function distributes keys evenly across the table. In general, quadratic probing can provide better performance than linear probing in these scenarios.\"), mdx(\"p\", null, \"However, when the load factor is high, quadratic probing can lead to a lot of probing, which can slow down the performance of the hash table. In these cases, it may be better to use other probing techniques, such as double hashing.\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"In this post, we have explored quadratic probing, a popular probing technique used in hash tables. We have compared it to linear probing and discussed its strengths and weaknesses. We have also discussed when it is appropriate to use quadratic probing in your code. With this knowledge, you can make better decisions when designing and implementing hash tables in your programs.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"What is Quadratic Probing?","date":"March 12, 2023","description":"In this blog post, we dive into the world of hash table probing and explore quadratic probing in detail. We compare it with other types of probing and discuss its strengths and weaknesses. By the end of this post, readers will have a better understanding of quadratic probing and when to use it in their code."}},"previous":{"fields":{"slug":"/blog/an-alternative-for-the-standard-hashmap-in-rust/"},"frontmatter":{"title":"An Alternative for the standard HashMap in Rust"}},"next":{"fields":{"slug":"/blog/understanding-rust-contextual-keywords/"},"frontmatter":{"title":"Understanding Rust Contextual Keywords"}}},"pageContext":{"id":"475f6618-059e-5e9d-9b12-53f93254d3c3","previousPostId":"82fed959-a5ca-5dc9-8167-840cf39c39db","nextPostId":"0efa9c7e-9827-505c-9800-d97885f7a79b"}},
    "staticQueryHashes": ["1804815106","2841359383"]}